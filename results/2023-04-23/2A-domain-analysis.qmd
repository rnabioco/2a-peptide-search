---
title: "2A domain analysis"
author: "JH"
format: html
editor: visual
---

## 2A domain analysis

```{r}
library(tidyverse)
library(here)
library(janitor)
```

```{r}
domains_c1_tbl <- read_tsv(here('results/2023-04-22/class-1.domain.hits.tsv.gz'), show_col_types = FALSE) |> mutate(class = 1)
domains_c2_tbl <- read_tsv(here('results/2023-04-22/class-2.domain.hits.tsv.gz'), show_col_types = FALSE) |> mutate(class = 2)

domains_tbl <- bind_rows(
  domains_c1_tbl, domains_c2_tbl
) |>
  unique() |>
  rename(record_id = `# record_id`) |>
  janitor::clean_names() |>
  mutate(
    db = case_when(
      str_detect(record_id, '^tr')  ~ 'uniprot',
      str_detect(record_id, '^MGY')  ~ 'mgnify',
      str_detect(record_id, '^UPI')  ~ 'uniparc',
      .default = 'unknown'
  )) |>
  arrange(record_id, query_start) |>
  filter(dom_evalue <= 0.01) |>
  # removes a few entries caused by cross-talk between the models
  filter(
    !(hit_id == '2A-class-2' & class == 1),
    !(hit_id == '2A-class-1' & class == 2)
  )

record_counts <- count(domains_tbl, record_id)
domains_tbl <- left_join(domains_tbl, record_counts) |> filter(n > 1)
```

## Domain neighbors

The following tallies the number of domains that neighbor 2A peptides. Many of the Uniparc entries are from synthetic constructs, so we need to eliminate those to get at biology.

```{r domain_org}
xx <- domains_tbl |>
  select(record_id, hit_id, starts_with('query'), db) |>
  group_by(record_id) |>
  mutate(
    nterm = lag(hit_id),
    nterm_overlap = query_start < lag(query_end),
    cterm = lead(hit_id)
    ) |>
  ungroup() |>
  filter(
    # !(is.na(nterm) & is.na(cterm)),
    nterm_overlap == FALSE,
    str_detect(nterm, '^2A') | str_detect(hit_id, '^2A'),
    ) |>
  select(record_id, nterm, hit_id, cterm, db) |>
  group_by(db, nterm, hit_id, cterm) |>
  count(hit_id, cterm, sort = TRUE)
  # slice_head(n = 10)
```

## 2A overlaps

Interval-based analysis to examine overlaps between 2A peptides and neighboring domains.

```{r}
domains_bed <-
  select(
    domains_tbl,
    chrom = record_id,
    start = query_start,
    end = query_end,
    name = hit_id,
    score = dom_evalue
  )

# takes ~10 seconds
ints <- bed_intersect(domains_bed, domains_bed)
ints |> filter(
  start.x != start.y & end.x != end.y,
  str_detect(name.x, "^2A") | str_detect(name.y, "^2A")
)

closest <- bed_closest(domains_bed, domains_bed)
closest_filt <-
  closest |>
  filter(
    start.x != start.y & end.x != end.y,
    str_detect(name.x, "^2A") | str_detect(name.y, "^2A")
  )
```

