---
title: "2A domain analysis"
author: "JH"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

## 2A domain analysis

```{r}
library(tidyverse)
library(here)
library(janitor)
library(valr)
```

```{r}
domains_c1_tbl <- read_tsv(here('results/2023-04-22/class-1.domain.hits.tsv.gz'), show_col_types = FALSE) |> mutate(class = 1)
domains_c2_tbl <- read_tsv(here('results/2023-04-22/class-2.domain.hits.tsv.gz'), show_col_types = FALSE) |> mutate(class = 2)

domains_tbl <- bind_rows(
  domains_c1_tbl, domains_c2_tbl
) |>
  unique() |>
  rename(record_id = `# record_id`) |>
  janitor::clean_names() |>
  mutate(
    db = case_when(
      str_detect(record_id, '^tr')  ~ 'uniprot',
      str_detect(record_id, '^MGY')  ~ 'mgnify',
      str_detect(record_id, '^UPI')  ~ 'uniparc',
      .default = 'unknown'
  )) |>
  mutate(
    db = as_factor(db),
    hit_id = as_factor(hit_id)
    ) |>
  arrange(record_id, query_start) |>
  filter(dom_evalue <= 0.01) |>
  # removes a few entries caused by cross-talk between the models
  filter(
    !(hit_id == '2A-class-2' & class == 1),
    !(hit_id == '2A-class-1' & class == 2)
  )

# remove synthetic constructs from uniparc
uniparc_ids_tbl <- read_tsv(here('results/2023-04-23/uniparc.orgs.tsv.gz')) |>
  rename(record_id = From, org = Organisms) |>
  select(record_id, org)

synthetic_uniparc_tbl <-
  filter(
    uniparc_ids_tbl,
    str_detect(org, 'synthetic') |
    str_detect(org, '[Cc]loning') |
    str_detect(org, '[Vv]ector') |
    str_detect(org, 'Homo sapiens')
  )

domains_tbl <- anti_join(domains_tbl, synthetic_uniparc_tbl)

record_counts <- count(domains_tbl, record_id)
domains_tbl <- left_join(domains_tbl, record_counts)
```

## Domain neighbors

The following tallies the number of domains that neighbor 2A peptides. Many of the Uniparc entries are from synthetic constructs, so we need to eliminate those to get at biology.

```{r domain_org}
dom_nearby <- domains_tbl |>
  select(record_id, hit_id, starts_with('query'), db) |>
  mutate(
    nterm = lag(hit_id),
    nterm_overlap = query_start < lag(query_end),
    cterm = lead(hit_id),
    .by = record_id
    ) |>
  filter(
    # !(is.na(nterm) & is.na(cterm)),
    # nterm_overlap == FALSE,
    str_detect(nterm, '^2A') | str_detect(hit_id, '^2A'),
    ) |>
  select(record_id, nterm, hit_id, cterm, db) |>
  count(db, nterm, cterm, hit_id, sort = TRUE)
```

## 2A overlaps

Interval-based analysis to examine overlaps between 2A peptides and neighboring domains.

```{r}
domains_bed <-
  select(
    domains_tbl,
    chrom = record_id,
    start = query_start,
    end = query_end,
    name = hit_id,
    score = dom_evalue,
    db, class
  )

# takes ~10 seconds
ints <- bed_intersect(domains_bed, domains_bed)
ints |> filter(
  start.x != start.y & end.x != end.y,
  str_detect(name.x, "^2A") | str_detect(name.y, "^2A")
)

closest <- bed_closest(domains_bed, domains_bed)
closest_filt <-
  closest |>
  filter(
    start.x != start.y & end.x != end.y,
    str_detect(name.x, "^2A") | str_detect(name.y, "^2A")
  )
```

